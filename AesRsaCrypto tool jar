

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.KeyGenerator;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.security.*;
import java.security.spec.*;
import java.util.*;

public class AesRsaCryptoTool {

    private static final String CONFIG_FILE = "src/main/resources/config.properties";

    public static void main(String[] args) {
        try {
            Properties config = loadProperties();

            if (args.length < 1) {
                System.out.println("Usage:");
                System.out.println("  To encrypt: java AesRsaCryptoTool E <path_to_input_file>");
                System.out.println("  To decrypt: java AesRsaCryptoTool D <path_to_encrypted_file> <path_to_encrypted_key_file>");
                return;
            }

            String choice = args[0].trim().toUpperCase();

            if ("E".equals(choice)) {
                if (args.length != 2) {
                    System.out.println("Usage for encryption: java AesRsaCryptoTool E <path_to_input_file>");
                    return;
                }
                encryptFlow(args[1], config);
            } else if ("D".equals(choice)) {
                if (args.length != 3) {
                    System.out.println("Usage for decryption: java AesRsaCryptoTool D <encrypted_file> <key_file>");
                    return;
                }
                decryptFlow(args[1], args[2], config);
            } else {
                System.out.println("❌ Invalid option. Use E or D.");
            }

        } catch (Exception e) {
            System.err.println("❌ Error: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void encryptFlow(String inputFilePath, Properties config) throws Exception {
        String outputFilePath = inputFilePath + ".enc";
        String keyEncPath = inputFilePath + ".key.enc";

        byte[] aesKey = generateAESKey();
        byte[] iv = Arrays.copyOfRange(aesKey, 0, 16);

        encryptFile(inputFilePath, outputFilePath, aesKey, iv);

        PublicKey publicKey = loadPublicKey(config.getProperty("publicKeyPath"));
        byte[] encryptedKey = encryptAESKeyWithRSA(aesKey, publicKey);

        Files.write(Paths.get(keyEncPath), encryptedKey);

        System.out.println("✅ File encrypted: " + outputFilePath);
        System.out.println("✅ AES key encrypted to: " + keyEncPath);
    }

    private static void decryptFlow(String encryptedFilePath, String encryptedKeyPath, Properties config) throws Exception {
        String decryptedFilePath = encryptedFilePath.replace(".enc", ".dec");

        byte[] encryptedKey = Files.readAllBytes(Paths.get(encryptedKeyPath));
        PrivateKey privateKey = loadPrivateKey(config.getProperty("privateKeyPath"));
        byte[] aesKey = decryptAESKeyWithRSA(encryptedKey, privateKey);
        byte[] iv = Arrays.copyOfRange(aesKey, 0, 16);

        decryptFile(encryptedFilePath, decryptedFilePath, aesKey, iv);

        System.out.println("✅ File decrypted: " + decryptedFilePath);
    }

    private static byte[] generateAESKey() throws Exception {
        KeyGenerator keyGen = KeyGenerator.getInstance("AES");
        keyGen.init(256);
        return keyGen.generateKey().getEncoded();
    }

    private static void encryptFile(String inputPath, String outputPath, byte[] key, byte[] iv) throws Exception {
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        SecretKeySpec keySpec = new SecretKeySpec(key, "AES");
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);

        try (FileInputStream fis = new FileInputStream(inputPath);
             CipherOutputStream cos = new CipherOutputStream(new FileOutputStream(outputPath), cipher)) {

            byte[] buffer = new byte[4096];
            int len;
            while ((len = fis.read(buffer)) != -1) {
                cos.write(buffer, 0, len);
            }
        }
    }

    private static void decryptFile(String inputPath, String outputPath, byte[] key, byte[] iv) throws Exception {
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        SecretKeySpec keySpec = new SecretKeySpec(key, "AES");
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);

        try (FileInputStream fis = new FileInputStream(inputPath);
             CipherInputStream cis = new CipherInputStream(fis, cipher);
             FileOutputStream fos = new FileOutputStream(outputPath)) {

            byte[] buffer = new byte[4096];
            int len;
            while ((len = cis.read(buffer)) != -1) {
                fos.write(buffer, 0, len);
            }
        }
    }

    private static byte[] encryptAESKeyWithRSA(byte[] aesKey, PublicKey publicKey) throws Exception {
        Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);
        return cipher.doFinal(aesKey);
    }

    private static byte[] decryptAESKeyWithRSA(byte[] encryptedKey, PrivateKey privateKey) throws Exception {
        Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
        cipher.init(Cipher.DECRYPT_MODE, privateKey);
        return cipher.doFinal(encryptedKey);
    }

    private static PublicKey loadPublicKey(String path) throws Exception {
        String pem = new String(Files.readAllBytes(Paths.get(path)), "UTF-8");
        String clean = pem.replaceAll("-----BEGIN PUBLIC KEY-----|-----END PUBLIC KEY-----|\\s", "");
        byte[] decoded = Base64.getDecoder().decode(clean);
        return KeyFactory.getInstance("RSA").generatePublic(new X509EncodedKeySpec(decoded));
    }

    private static PrivateKey loadPrivateKey(String path) throws Exception {
        String pem = new String(Files.readAllBytes(Paths.get(path)), "UTF-8");
        String clean = pem.replaceAll("-----BEGIN PRIVATE KEY-----|-----END PRIVATE KEY-----|\\s", "");
        byte[] decoded = Base64.getDecoder().decode(clean);
        return KeyFactory.getInstance("RSA").generatePrivate(new PKCS8EncodedKeySpec(decoded));
    }

    private static Properties loadProperties() throws IOException {
        Properties props = new Properties();
        try (InputStream input = new FileInputStream(CONFIG_FILE)) {
            props.load(input);
        }
        return props;
    }
}





























import javax.crypto.Cipher; import javax.crypto.CipherInputStream; import javax.crypto.CipherOutputStream; import javax.crypto.KeyGenerator; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.SecretKeySpec; import java.io.; import java.nio.file.; import java.security.; import java.security.spec.; import java.util.*;

public class AesRsaCryptoTool {

public static void main(String[] args) {
    try {
        if (args.length < 1) {
            printUsage();
            return;
        }

        String operation = args[0].trim().toUpperCase();
        Properties config = loadPropertiesFromClasspath();

        switch (operation) {
            case "E":
                if (args.length != 2) {
                    System.err.println("❌ Invalid args for encryption.");
                    printUsage();
                    return;
                }
                encryptFlow(args[1], config);
                break;

            case "D":
                if (args.length != 3) {
                    System.err.println("❌ Invalid args for decryption.");
                    printUsage();
                    return;
                }
                decryptFlow(args[1], args[2], config);
                break;

            default:
                System.err.println("❌ Invalid operation. Use E or D.");
                printUsage();
        }
    } catch (Exception e) {
        System.err.println("❌ Error: " + e.getMessage());
        e.printStackTrace();
    }
}

private static void encryptFlow(String inputFilePath, Properties config) throws Exception {
    String outputFilePath = inputFilePath + ".enc";
    String keyEncPath = inputFilePath + ".key.enc";

    byte[] aesKey = generateAESKey();
    byte[] iv = Arrays.copyOfRange(aesKey, 0, 16);

    String padding = config.getProperty("aesPadding", "PKCS5Padding");
    encryptFile(inputFilePath, outputFilePath, aesKey, iv, padding);

    PublicKey publicKey = loadPublicKey(config.getProperty("publicKeyPath"));
    byte[] encryptedKey = encryptAESKeyWithRSA(aesKey, publicKey);
    Files.write(Paths.get(keyEncPath), encryptedKey);

    System.out.println("✅ File encrypted: " + outputFilePath);
    System.out.println("✅ AES key encrypted to: " + keyEncPath);
}

private static void decryptFlow(String encryptedFilePath, String encryptedKeyPath, Properties config) throws Exception {
    String decryptedFilePath = encryptedFilePath.replace(".enc", ".dec");

    byte[] encryptedKey = Files.readAllBytes(Paths.get(encryptedKeyPath));
    PrivateKey privateKey = loadPrivateKey(config.getProperty("privateKeyPath"));
    byte[] aesKey = decryptAESKeyWithRSA(encryptedKey, privateKey);
    byte[] iv = Arrays.copyOfRange(aesKey, 0, 16);

    String padding = config.getProperty("aesPadding", "PKCS5Padding");
    decryptFile(encryptedFilePath, decryptedFilePath, aesKey, iv, padding);

    System.out.println("✅ File decrypted: " + decryptedFilePath);
}

private static void printUsage() {
    System.out.println("Usage:");
    System.out.println("  Encrypt: java -jar AesRsaCryptoTool.jar E <inputFile>");
    System.out.println("  Decrypt: java -jar AesRsaCryptoTool.jar D <encryptedFile> <encryptedKeyFile>");
    System.out.println("Note: config.properties should be in the resources folder.");
}

private static byte[] generateAESKey() throws Exception {
    KeyGenerator keyGen = KeyGenerator.getInstance("AES");
    keyGen.init(256);
    return keyGen.generateKey().getEncoded();
}

private static void encryptFile(String inputPath, String outputPath, byte[] key, byte[] iv, String padding) throws Exception {
    Cipher cipher = Cipher.getInstance("AES/CBC/" + padding);
    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, "AES"), new IvParameterSpec(iv));

    try (FileInputStream fis = new FileInputStream(inputPath);
         CipherOutputStream cos = new CipherOutputStream(new FileOutputStream(outputPath), cipher)) {

        byte[] buffer = new byte[4096];
        int len;
        while ((len = fis.read(buffer)) != -1) {
            cos.write(buffer, 0, len);
        }
    }
}

private static void decryptFile(String inputPath, String outputPath, byte[] key, byte[] iv, String padding) throws Exception {
    Cipher cipher = Cipher.getInstance("AES/CBC/" + padding);
    cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, "AES"), new IvParameterSpec(iv));

    try (FileInputStream fis = new FileInputStream(inputPath);
         CipherInputStream cis = new CipherInputStream(fis, cipher);
         FileOutputStream fos = new FileOutputStream(outputPath)) {

        byte[] buffer = new byte[4096];
        int len;
        while ((len = cis.read(buffer)) != -1) {
            fos.write(buffer, 0, len);
        }
    }
}

private static byte[] encryptAESKeyWithRSA(byte[] aesKey, PublicKey publicKey) throws Exception {
    Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
    cipher.init(Cipher.ENCRYPT_MODE, publicKey);
    return cipher.doFinal(aesKey);
}

private static byte[] decryptAESKeyWithRSA(byte[] encryptedKey, PrivateKey privateKey) throws Exception {
    Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
    cipher.init(Cipher.DECRYPT_MODE, privateKey);
    return cipher.doFinal(encryptedKey);
}

private static PublicKey loadPublicKey(String path) throws Exception {
    String pem = Files.readString(Paths.get(path));
    String clean = pem.replaceAll("-----BEGIN PUBLIC KEY-----|-----END PUBLIC KEY-----|\\s", "");
    byte[] decoded = Base64.getDecoder().decode(clean);
    return KeyFactory.getInstance("RSA").generatePublic(new X509EncodedKeySpec(decoded));
}

private static PrivateKey loadPrivateKey(String path) throws Exception {
    String pem = Files.readString(Paths.get(path));
    String clean = pem.replaceAll("-----BEGIN PRIVATE KEY-----|-----END PRIVATE KEY-----|\\s", "");
    byte[] decoded = Base64.getDecoder().decode(clean);
    return KeyFactory.getInstance("RSA").generatePrivate(new PKCS8EncodedKeySpec(decoded));
}

private static Properties loadPropertiesFromClasspath() throws IOException {
    Properties props = new Properties();
    try (InputStream input = AesRsaCryptoTool.class.getClassLoader().getResourceAsStream("config.properties")) {
        if (input == null) {
            throw new FileNotFoundException("config.properties not found in classpath.");
        }
        props.load(input);
    }
    return props;
}

}

